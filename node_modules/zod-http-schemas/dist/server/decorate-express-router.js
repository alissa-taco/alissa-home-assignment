"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateExpressRouter = void 0;
// NB: express imports will be elided in the built js code, since we are only importing types.
const express = require("express");
const z = require("zod");
/**
 * Returns a decorated copy of the given express application or router, with strongly-typed `get`/`post` methods
 * and runtime validation checks on request/response bodies. The given app/router is not modified.
 */
function decorateExpressRouter(options) {
    var _a;
    // Return a new app/router with some overridden methods. The original app/router is left unchanged.
    let router = (_a = options.router) !== null && _a !== void 0 ? _a : express.Router();
    let result = (req, res, next) => router(req, res, next);
    Object.assign(result, {
        ...options.router,
        get: (path, ...handlers) => handle('GET', path, ...handlers),
        post: (path, ...handlers) => handle('POST', path, ...handlers),
        put: (path, ...handlers) => handle('PUT', path, ...handlers),
    });
    return result;
    // This function wraps express' normal get/post methods, adding runtime checks for schema conformance.
    function handle(method, path, ...handlers) {
        // Get the route info from the schema for this method/path.
        let matchingRoutes = Object.values(options.schema).filter((r) => r.method === method && r.path === path);
        let routeInfo = matchingRoutes[0];
        if (matchingRoutes.length !== 1) {
            const problem = matchingRoutes.length > 1 ? 'multiple routes' : 'no route';
            throw new Error(`Schema has ${problem} for method '${method}' and path '${path}'`);
        }
        // Elements of `handlers` can actually be arrays, so flatten the `handlers` array before proceeding.
        handlers = flatDeep(handlers);
        // Wrap each handler to ensure that if it throws or rejects, then it calls `next` with the error.
        // This ensures that *all* unhandled errors in route handlers are propagated to error middleware (if any).
        let errorPropagatingHandlers = handlers.map((handler) => async (req, res, next) => {
            try {
                // If `handler` throws (sync) or rejects (async), we'll hit the catch clause either way.
                await handler(req, res, next);
            }
            catch (err) {
                // Unhandled error from handler - call `next` with the error to trigger error middleware (if any).
                next(err);
            }
        });
        // Register the list of wrapped handlers for the given method/path with the underlying express app/router.
        // Also prepend middleware that ensures req/res objects are validated and have excess properties removed.
        const m = method.toLowerCase();
        const validateRequestProps = createRequestPropValidationMiddleware(options.requestProps || z.unknown());
        const validateBodies = createBodyValidationMiddleware(routeInfo, options.onValidationError);
        router[m](path, validateRequestProps, validateBodies, ...errorPropagatingHandlers);
    }
}
exports.decorateExpressRouter = decorateExpressRouter;
/** Creates a middleware function that validates request properties against the given schema. */
function createRequestPropValidationMiddleware(requestProps) {
    return (req, _, next) => {
        requestProps.parse(req);
        next();
    };
}
/** Creates a middleware function that validates request params/body and response body for the given `routeInfo`. */
function createBodyValidationMiddleware(routeInfo, onValidationError) {
    onValidationError =
        onValidationError !== null && onValidationError !== void 0 ? onValidationError : ((err, _, res) => {
            res.status(400).json(err);
            console.error(err);
        });
    return (req, res, next) => {
        var _a;
        // Validate the incoming request params (parsed out of the request path by express) against the schema.
        // If the params object is not as expected, it is likely a server-side configuration error, such as `path`
        // and `params` not matching properly in the HTTP schema. Since the error is likely server-side, pass the
        // error to `next`. This will skip subsequent middleware and trigger error middleware (if any).
        let actualNamedParams = Object.keys(req.params);
        let expectedNamedParams = routeInfo.namedParams || [];
        let missingNamedParams = expectedNamedParams.filter((p) => !actualNamedParams.includes(p));
        let excessNamedParams = actualNamedParams.filter((p) => !expectedNamedParams.includes(p));
        if (missingNamedParams.length > 0 || excessNamedParams.length > 0) {
            let msg = 'The named parameters in the request do not match the schema.';
            if (missingNamedParams.length > 0)
                msg += ` Missing: "${missingNamedParams.join('", "')}".`;
            if (excessNamedParams.length > 0)
                msg += ` Excess: "${excessNamedParams.join('", "')}".`;
            return next(new Error(msg));
        }
        // Validate and clean the incoming request body against the schema. If the request body is invalid,
        // delegate to the `onValidationError` handler, which is expected to respond appropriately.
        // If no `onValidationError` callback is given, the default behaviour is to send a 400 response, since
        // having an invalid request structure signifies a client error.
        try {
            // TODO: test that this actually replaces the req.body value
            req.body = validateAndClean(req.body, (_a = routeInfo.requestBody) !== null && _a !== void 0 ? _a : z.union([z.object({}), z.undefined()]));
        }
        catch (err) {
            onValidationError(err, req, res, next);
            return;
        }
        // Ensure outgoing response bodies are validated and cleaned against the schema before they are sent.
        // This is done by wrapping methods on the `res` object, so subsequent handlers call the wrapped versions.
        // Note that validation errors will throw in the handler that caused them, in which case the error will
        // be passed to `next` and hence any error handling middleware (by default will respond with a 500 error).
        const { json, jsonp, send } = res; // the original json/jsonp/send methods to be wrapped
        res = Object.assign(res, {
            json: (body) => json.call(res, validateAndClean(body, routeInfo.responseBody)),
            jsonp: (body) => jsonp.call(res, validateAndClean(body, routeInfo.responseBody)),
            send: (body) => typeof body === 'string' ? send.call(res, body) : res.json(body),
        });
        // Param/body checking is done. Pass on to subsequent middleware for further processing.
        next();
    };
    // Helper function to runtime-validate that the body is the expected type, and to remove excess properties.
    function validateAndClean(value, type = z.undefined()) {
        return type.parse(value);
    }
}
// Helper function - equivelent of Array#flat, which is newish.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
function flatDeep(arr) {
    return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val) : val), []);
}
//# sourceMappingURL=decorate-express-router.js.map