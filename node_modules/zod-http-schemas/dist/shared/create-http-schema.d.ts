import { ExtractMethod, ExtractPath } from '../util';
import { Method } from './methods';
import { RouteInfo } from './route-info';
import { ZodTypeAny } from 'zod';
/**
 * Creates a HttpSchema object from the given route specifications.
 * HTTP schemas may be passed to `createHttpClient` and/or `decorateExpressServer` to implement the schema on the
 * client-side and/or server-side. See those functions for more details.
 */
export declare function createHttpSchema<RS extends RouteSpecs>(routeSpecs: RS): {
    [R in keyof RS]: ExtractRouteInfo<RS, R>;
};
/** Route specifications, given as an object keyed by route, with values describing the req/res body shape per route. */
export interface RouteSpecs {
    [route: `${Method} ${string}`]: {
        requestBody?: ZodTypeAny;
        responseBody?: ZodTypeAny;
    };
}
/** A HTTP Schema declared as an object keyed by route, with values containing detailed information about each route. */
export interface HttpSchema {
    [route: string]: RouteInfo;
}
declare type ExtractRouteInfo<Schema extends RouteSpecs, Route extends keyof Schema> = Anonymise<{
    method: ExtractMethod<Route>;
    path: ExtractPath<Route>;
    namedParams: Array<ExtractNamedParams<ExtractPath<Route>> | ExtractNumberedParams<ExtractPath<Route>>>;
    requestBody: Schema[Route] extends {
        requestBody: infer T;
    } ? T : never;
    responseBody: Schema[Route] extends {
        responseBody: infer T;
    } ? T : never;
}>;
declare type ExtractNamedParams<Path, Parts = Tail<Split<Path, ':'>>> = ExtractUntilDelim<Parts[any]>;
declare type ExtractUntilDelim<S> = S extends `${Delim}${string}` ? '' : S extends `${infer First}${infer Rest}` ? `${First}${ExtractUntilDelim<Rest>}` : '';
declare type Delim = '/' | ':' | '-' | '.' | '~' | '!' | '$' | '&' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '@' | '%';
declare type ExtractNumberedParams<Path, Parts = Split<Path, '/'>> = Filter<Parts, '*'> extends [...infer U] ? {
    [K in keyof U]: K;
}[any] : never;
declare type Anonymise<Obj> = Anonymise2<{
    [K in keyof Obj]: Obj[K];
}>;
declare type Anonymise2<T> = T;
declare type Split<Str, Sep extends string> = Str extends `${infer First}${Sep}${infer Rest}` ? [First, ...Split<Rest, Sep>] : [Str];
declare type Tail<Tuple extends any[]> = Tuple extends [any, ...infer Rest] ? Rest : never;
declare type Filter<Tuple, U> = Tuple extends [infer First, ...infer Rest] ? First extends U ? [U, ...Filter<Rest, U>] : Filter<Rest, U> : [];
export {};
