"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGetOnlyServer = exports.createTestServer = void 0;
const bodyParser = require("body-parser");
const compression = require("compression");
const cookieParser = require("cookie-parser");
const express = require("express");
const useragent = require("express-useragent");
const morgan = require("morgan");
const server_1 = require("../../server");
const test_schema_1 = require("./test-schema");
function createTestServer() {
    const RequestProps = server_1.z.object({
        // `req.useragent` prop added by useragent middleware
        useragent: server_1.z.object({
            isMobile: server_1.z.boolean(),
            isDesktop: server_1.z.boolean(),
            browser: server_1.z.string(),
            os: server_1.z.string(),
            platform: server_1.z.string(),
            // ...and more
        }),
    });
    // Implement the HTTP schema using an Express Router instance.
    const typedRoutes = (0, server_1.decorateExpressRouter)({
        schema: test_schema_1.testSchema,
        requestProps: RequestProps,
        onValidationError: (err, _, res) => {
            console.log(err);
            res
                .status(200)
                .send({ success: false, code: 'MY_CUSTOM_VALIDATION_ERROR' });
        },
    });
    // Specify some route handlers inline
    typedRoutes.get('/random-numbers', (req, res) => {
        req.useragent.isMobile;
        res.send([Math.random(), Math.random(), Math.random()]);
    });
    typedRoutes.post('/sum', (req, res) => {
        let result = req.body.reduce((sum, n) => sum + n, 0);
        res.send(result);
    });
    typedRoutes.get('/404', (req, res) => {
        res.status(404).json({ error: 'Resource not found' });
    });
    // Specify some route handlers separately and then add them to the app.
    const handleProduct = (0, server_1.createRequestHandler)({
        schema: test_schema_1.testSchema,
        route: 'POST /product',
        requestProps: RequestProps,
        handler: (req, res) => {
            req.useragent.isMobile;
            let result = req.body.reduce((sum, n) => sum * n, 1);
            res.status(200).send(result);
        },
    });
    const handleWildcard = (0, server_1.createRequestHandler)(test_schema_1.testSchema, 'GET *', (req, res) => {
        if (req.params['0'] === '/hello') {
            res.status(200).send(`Hello, ${req.body.name}!`);
        }
        else {
            res.status(500).send('Server error');
        }
    });
    const handleMultiply = (0, server_1.createRequestHandler)({
        schema: test_schema_1.testSchema,
        route: 'PUT /multiply',
        requestProps: RequestProps,
        handler: (req, res) => {
            const { first, second } = req.body;
            const result = first * second;
            res.send(result);
        },
    });
    typedRoutes.post('/product', handleProduct);
    typedRoutes.put('/multiply', handleMultiply);
    typedRoutes.get('*', handleWildcard);
    const handleSumNegative = (0, server_1.createRequestHandler)({
        schema: test_schema_1.testSchema,
        route: 'POST /sum/negative',
        handler: (req, res) => {
            const numbers = req.body;
            const result = numbers.reduce((acc, val) => acc + val, 0);
            res.send(result);
        },
    });
    typedRoutes.post('/sum/negative', handleSumNegative);
    const handleSumNegativeBuggy = (0, server_1.createRequestHandler)({
        schema: test_schema_1.testSchema,
        route: 'POST /sum/negative',
        handler: (req, res) => {
            const numbers = req.body;
            const result = numbers.reduce((acc, val) => acc - val, 0);
            res.send(result);
        },
    });
    typedRoutes.post('/sum/negative-broken', handleSumNegativeBuggy);
    typedRoutes.post('/sum/transform-string', async (req, res) => {
        const numbers = req.body;
        const result = numbers.reduce((acc, val) => acc + val, 0);
        res.send(result);
    });
    typedRoutes.post('/sum/transform-response', async (req, res) => {
        const numbers = req.body;
        const result = numbers.reduce((acc, val) => acc + val, 0);
        res.send(result);
    });
    typedRoutes.post('/sum/with-query-param', async (req, res) => {
        const numbers = req.body;
        const result = numbers.reduce((acc, val) => acc + val, 0) + parseInt(req.query.alsoAdd);
        res.send(result);
    });
    // Create an Express Application and add middleware to it, including our HTTP schema implementation.
    const app = express();
    app.use(compression());
    app.use(cookieParser());
    app.use(morgan('combined'));
    app.use(useragent.express());
    app.use(bodyParser.json());
    app.use('/api', typedRoutes);
    // Return an object that allows the caller to start and stop the HTTP server.
    return {
        start() {
            return new Promise((resolve) => {
                server = app.listen(8000, () => resolve());
            });
        },
        stop() {
            return new Promise((resolve) => {
                server.close(() => resolve());
            });
        },
    };
}
exports.createTestServer = createTestServer;
let server;
const log = (req, _, next) => {
    console.log(`Incoming request: ${req.path}`);
    next();
};
const createGetOnlyServer = () => {
    // Implement the HTTP schema using an Express Router instance.
    const typedRoutes = (0, server_1.decorateExpressRouter)({
        schema: test_schema_1.testGetOnlySchema,
    });
    // Specify some route handlers inline
    typedRoutes.get('/random-numbers', [log], (req, res) => {
        res.send([Math.random(), Math.random(), Math.random()]);
    });
    // Create an Express Application and add middleware to it, including our HTTP schema implementation.
    const app = express();
    app.use(compression());
    app.use(cookieParser());
    app.use('/api', typedRoutes);
    // Return an object that allows the caller to start and stop the HTTP server.
    let server;
    return {
        start() {
            return new Promise((resolve) => {
                server = app.listen(8000, () => resolve());
            });
        },
        stop() {
            return new Promise((resolve) => {
                server.close(() => resolve());
            });
        },
    };
};
exports.createGetOnlyServer = createGetOnlyServer;
//# sourceMappingURL=test-server.js.map